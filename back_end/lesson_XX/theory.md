# Reflection


--------------------------------------------------------------------------

# Reflection 

1. **JVM (Java Virtual Machine)**
Это виртуальная машина, которая выполняет байт-код Java (машинный код), полученный после компиляции исходного текстового кода Java. Она является основой для запуска Java-приложений. JVM интерпретирует байт-код и управляет выполнением программы, включая управление памятью, выполнение потоков, загрузку классов и т.д.

2. **Java Reflection API:** 
Это набор классов и интерфейсов, который позволяет программам получать информацию о классах, полях, методах, аннотациях во время выполнения (runtime). Это делает возможным интроспекцию классов (способность программы изучать свою собственную структуру, типы данных, свойства и методы во время выполнения), динамическое создание объектов, вызов методов и другие операции с классами во время выполнения.

Как это работает? Для чего это нужно?

1. В специальном разделе JVM именуемом Classloader находятся объекты рефлексии (зеркальное отображение) для каждого типа данных используемого в каждом Java-проекте (классы, объекты, методы и т.д.).

2. Объекты рефлексии содержат в себе всю информацию о типах данных в соответствующих объектах.

3. Для типизации Объектов рефлексии существует класс Class<T>.

4. Получить ссылку на объект рефлексии можно тремя способами. 
Например, ссылку на объект рефлексии класса String можно получить или у самого класса: String.class, или у объекта класса: "hello".getClass(), или по имени класса: Class.forName("java.lang.String").

5. В Java Reflection API существуют типы ответственные за любые элементы объектов: поля, методы, конструкторы и т. д.

**Java Reflection API** — это набор классов и интерфейсов в Java, который позволяет программам получать информацию о своей структуре (классы, интерфейсы, поля, методы), а также манипулировать этой информацией во время выполнения (runtime).

С помощью **Java Reflection API** можно выполнять следующие действия:
1. Получение информации о классе: Узнать о полях, методах, конструкторах класса, аннотациях и других свойствах класса.
2. Манипуляция с полями класса: Получать и изменять значения полей класса.
3. Манипуляция с методами класса: Вызывать методы класса динамически во время выполнения.
4. Манипуляция с аннотациями: Получать информацию об аннотациях, присущих классам, методам или полям, и использовать их для принятия решений во время выполнения.
5. Создание новых объектов во время выполнения: Создавать экземпляры классов динамически во время выполнения.

Java Reflection API предоставляет классы, такие как Class, Field, Method, Constructor и другие, которые позволяют получать информацию о структуре классов и манипулировать ими.

Это мощный инструмент, который часто используется во фреймворках, библиотеках и инструментах, которые нуждаются в динамическом анализе и изменении классов во время выполнения программы.


===================================================================================


# Теория курса Java basic_programming (повторение)

## Системы счисления
10 - ая: десятичная, десятиричная система счисления.
0, 1, 2, 3, ..., 9

Основание - 10, каждая цифра числа получается % 10 (деление с остатком).
54321 % 10 = 1
54321 / 10 = 5432

8 - ая:
восьмиричная, 8, остатки от деления: 0, 1, 2, ... , 7
8(10) = 10(8)

16 - ая:
шеснадцатиричная, 16, 0, 1, 2, ... , 9 , A, B, С, D..., F

2 - ая:
двоичная, 2 - основание, 0, 1
4 (10) = 100 (2)


## Примитивные типы данных
int, byte, short, long, float, double, char, boolean

При объявлении каждой переменной, метод необходимо объявить ее ТИП.

## Методы
- СИГНАТУРА метода
- название метода надо давать с маленькой буквы!!!
- если метод ничего не возвращает, то надо написать void (английское слово)
- конструктор - это ТОЖЕ МЕТОД

  `public int add(int a, int b) {
  // тело метода
  return a + b;
  }`

## Условие, тернарный оператор, switch case
    `if()`

    `if(condidtion) {
    } else {
    }`

тернарный оператор помогает сильно сократить код и должно быть простое условие
пример: 
    `int index < 0 ? -index : index;`

    `switch case` 
- организует код, когда множественный выбор

## Циклы - while, do while, for


## Массивы

String[] word
int[] numbers
int[] arr

Как выглядит текущий элемент массива? - arr[i]
Следующий за ним?  - arr[i + 1]
Предыдущий элемент? - arr[i - 1]
Первый элемент? - arr[0]
Последний? - arr[arr.length - 1]

arr.length - длина, кол-во элементов

## Сортировка массива
- пузырьковая
- сортировка выбором
- ...

Они (сортировки) нужны, потому что БИНАРНЫЙ поиск в отсортированном массиве - это самый быстрый поиск O(log(n))

## Принципы ООП
- инкапсуляция (все в классе ...)
- полиморфизм (перегрузка методов, разный набор аргументов ... )
- наследование (extends класса, implements от интерфейса )
- абстракция (абстрагируемся от конкретики, выделяем общие свойства объектов, берем только то, что нам надо...)


## Что такое класс, объекты, конструктор и т.д.


## Абстрактные классы
- на базе абстрактного класса нельзя создавать объекты, объекты создаются - в дочерних классах.


## Интерфейсы
- содержат только абстрактные методы (нет тела).


## Классы-обертки
Integer, Byte, Character, Boolean, ...
Расширяют методы для работы с такими данными.

## Enum
Класс, содержит перечислимый тип данных типа констант.
У каждой константы можно определить поля.


## Arrays, binarySearch
Arrays - это класс-обертка над array.

binarySearch - это метод, который возвращает индекс искомого элемента.
Индекс > 0 - элемент найден
Индекс < 0 - элемент НЕ найден, мог бы/должен стоять на - i - 1 месте.

## Generics
<T>, <E> - параметры интерфейсов, тип данных может быть/должен быть определен на этапе создания объекта.

## Comparable, Comparator
Comparable - для класса, задает метод compareTo, текущий сравниваем с присланным в метод. Желательно, чтобы
это был естественный (native) метод сортировки для объектов этого класса.

Компаратор - определяем на основе встроенного интерфейса в Java там, где нужен. Определяет метод compare (T o1, T o2).

## Complexity
O(1) - константная, конечное кол-во операций.
O(log(n)) - логарифмическая.
O(n) - линейная, кол-во операций прямо пропорционально кол-ву элементов.
O(n2) - квадратичная.
O(...)

## JCF структуры
Iterable - hasNex(), next()

Collection - sort, CRUD-методы, ...

Списки - List, очереди - ..., Множества - Set

Списки: возможны дубликаты, есть индексы элементов, сортируемы, поиск и добавление - O(n) - линейная, не нужно следить за размером.

Множества: уникальность элементов, НЕТ индексов, HashSet - НЕ сортируется, поиск и добавление - O(1) - константная.
TreeSet: уникальность элементов, НЕТ индексов, TreeSet - сортируется при наполнении элементами СРАЗУ, поиск и добавление - O(log(n)).

Map (мапа) - это комбинация/соединение **множества** ключей и **списков** их значений.

## Java Time API
см. примеры:
LocalDate.now - текущая дата
ChronoUnits - дни, недели, полнедели, полмесяца, месяц, век и т.д.

## Java Stream API


## Exceptions, try catch, throw
 


