# Theory


-------------------------------------------------------

# Теория

## 01. Безопасность в приложении

* Аутентификация - процесс, при котором приложение запрашивает логин и пароль и проверяет их корректность
  * проверка подлинности данных пользователя
* Авторизация - процесс, при котором приложение проверяет права пользователя на выполнение каких-либо операций
  * например, проверка на возможность получения пользователем всех курсов по адресу `/courses`
* HTTP-сессия - это объект (сущность с полями), который хранится на сервере, с которым может быть ассоциирован конкретный пользователь.

## 02. Процесс аутентификации на основе сессии

* Клиент отправляет POST-запрос на сервер по адресу `api/login`;
* В теле запроса клиент передает данные для аутентификации, как минимум, email и пароль;
* Сервер проверяет корректность этих данных (находит пользователя в базе, вычисляет хеш введенного пароля, сравнивает его с тем, который есть в базе);
* Если данные для входа корректные, то сервер в оперативной памяти создает объект сессии:
  * ассоциирует с этим объектом данные пользователя;
  * назначает объекту идентификатор;
  * отправляет клиенту этот идентификатор, который на клиенте сохраняется в "куках" браузера.

Финал этого процесса: пользователь проверен, с ним можно дальше "работать".

## 03. Процесс авторизации на основе сессии

* Клиент посылает свой запрос вместе с кукой, которая содержит идентификатор сессии;
* Сервер по этому идентификатору находит сессию в хранилище и получает ее атрибуты (в нашем случае это пользователь);
* Получив пользователя, сервер проверяет его роль и доступ к определенному endpoint на основе правил (опишем далее);
* Клиенту возвращается либо запрошенный ресурс, либо 403-статус (Запрещено).

### Полезно знать:

1. При использовании для REST API на практике чаще применяется подход, основанный на JWT-токенах - специальных маркерах, которые позволяют отличать по принципу свой-чужой.
2. На собеседовании могут спросить, а где в итоге хранится сессия? Правильный ответ: на сервере, на клиенте мы храним только ее идентификатор.
3. В атрибутах сессии не должен хранится текущий пользователь из соображений безопасности.
4. Если приложение перезапустить, то сессия сбрасывается и всем пользователям нужно заново войти в него.
5. Если пользователь сделает logout, то в этом случае сессия тоже сбрасывается.
6. Время "жизни" в простое сессии Spring Boot зависит от настроек приложения, по умолчанию - 30 минут.
7. Почему сессии - это удобно? На frontend не нужно контролировать сохранение идентификатора сессии и его отправку. 
8. Проблема сессий - это не универсальный механизм, для других типов клиентов (например, мобильных приложений) они не используются. 
9. Если необходимо сделать так, чтобы при перезагрузке сервера сессии не очищались и всем пользователям не приходилось заново логиниться - нужно хранить сессии в БД (обычно используют REDIS).

## 04. Настройка безопасности Spring Boot с Spring Security

* При подключении Spring Boot Starter Security появляется:
  * Страница входа;
  * Защита всех endpoints;
  * Логин `user;
  * Пароль генерируется в консоли;
* Но мы хотим, чтобы люди заходили под своими логинами и паролями.

### Шаги по настройке Spring Security

1. Создать класс-реализацию интерфейса `UserDetails`
  * Данный класс нужен для того, чтобы адаптировать пользователя под безопасность Spring Security
  * По сути, это адаптер нашего класса `User` для `Spring Security`
  * В нашем случае это класс `AuthenticatedUser`
2. Создать класс-реализацию интерфейса `UserDetailsService`
  * Данный класс нужен для того, чтобы показать Spring Security откуда брать пользователя для проверки
  * В нашем случае это класс `UserDetailsServiceImpl`
3. Настройка конфигурации Spring Security (см. комментарии в коде)
4. Проверить работу endpoints