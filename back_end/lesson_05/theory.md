


==========================================================

## Тестирование проекта

* Чтобы протестировать **репозиторий**, который отвечает за работу с данными:
    * Нельзя использовать для тестирования "боевую" базу данных (файл), которая используется в основном проекте.
    * Необходимо сделать временный файл (временную базу данных) перед каждым тестом, которую будем сразу удалять его после каждого теста.
    * Такой подход позволяет не повредить или как-либо изменить те данные, которые нам важны в основном проекте.

* Чтобы протестировать **сервис**, необходимо:
    * Создать временную заглушку, `mock`-реализацию для конкретного теста.
    * Для этой реализации мы явно опишем какие значения должен возвращать тот или иной метод.
    * Такой подход называется mock-тестированием и используется в Unit/Модульных тестах.
    * В тестах мы проверяем ТОЛЬКО наш класс (сервис), независимо от того, как работают другие классы(слои) и их методы, чтобы точно понять причину ошибки в классе/методе сервиса.
    * Mock-тестирование позволяет "обложить" сервис "заглушками", чтобы сервис "не дергал" репозиторий, а работал изолированно во время теста.

* Используемые аннотации:
  * `@BeforeEach` - аннотация JUnit, которой мы можем пометить метод, запускаемый перед каждым тестом автоматически
  * `@AfterEach` - аннотация JUnit, которой мы можем пометить метод, запускаемый после каждого теста
  * `@Nested` - аннотация, которой можно помечать вложенные классы с тестами
      * Вложенные классы используем для группировки тестов, каждый вложенный класс может содержать тесты для конкретного метода

## Заметки

* `Arrays.asList(T ... a)` - создает `ArrayList` на основе набора объектов.
* `Mockito` - библиотека для Mock-тестирования.
* `.class` - получение описания типа какого-либо класса, используется, когда Java нужно проверить, принадлежит ли какой-либо объект какому-то классу.
* `stubbing` - процесс, когда мы явно прописываем реализацию какой-либо заглушки
* `verify` - подходит, когда нужно проверить, был ли вызван void-метод

## Словарик

* `before each` - перед каждым
* `after each` - после каждого
* `temp` - временный
* `exists` - существует (содержится)
* `nested` - внутренний
* `expected` - ожидаемый (тот результат, который мы ожидаем)
* `actual` - актуальный (тот результат, который нам пришел по факту)
* `replace underscores` - заменить нижние подчеркивания

### Общение с чатом GPT

```
Привет!

Должен ли специалист по автоматизированному тестрованию знать, что такое mock-тестирование?

ChatGPT
Привет!

Да, специалист по автоматизированному тестированию должен быть знаком с понятием mock-тестирования.
 Mock-тестирование (или мок-тестирование) - это методика тестирования, 
 когда создаются фиктивные (заглушки) компоненты или объекты, 
 которые имитируют поведение реальных компонентов в системе. 
 Это позволяет изолировать тестируемый компонент от зависимостей, 
 которые могут влиять на результаты тестирования.

С помощью mock-объектов можно симулировать различные сценарии и 
взаимодействия, которые могут быть сложно воссозданы в реальной 
среде тестирования. Это особенно полезно, когда какие-либо
зависимости компонента, такие как базы данных, внешние сервисы или компоненты 
других команд, не готовы или не стабильны на момент тестирования.

С использованием mock-тестирования можно проверить, как компонент
 взаимодействует с окружающей системой, как он обрабатывает данные и какие вызовы
он осуществляет, не запуская всю систему целиком. Это помогает выявить проблемы в изоляции 
и обработке данных, а также упрощает отладку и тестирование отдельных частей приложения.

Таким образом, знание о mock-тестировании будет полезным для 
специалиста по автоматизированному тестированию, чтобы эффективно 
тестировать компоненты в изоляции и обеспечивать надежную и стабильную работу всей системы.
```
