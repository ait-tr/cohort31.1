# Theory


==========================================================
# Теория

## Слабая связь между компонентами приложения (классами, слоями) - это нужно, исходя из требований гибкости и развития приложения

* Благодаря тому, что классы создаются на базе **интерфейсов** (implements), мы можем менять конфигурацию приложения в Main, подставляя разные реализации одних и тех же интерфейсов.

* В реальных приложениях компонентов(классов) и, соответственно, слоев может быть достаточно много, например:
  * Слой сервисов для обычного пользователя и администратора
  * Различные виды валидаторов для обслуживания форм ввода данных
  * Контроллеры на разные запросы пользователей (переходы по меню)
  * Разные репозитории и их типы (например, подключения к разным СУБД)
  
* В приложениях, где таких компонентов много, становится трудно самостоятельно создавать объекты и связывать их между собой (как в примере Main)

## Spring

* Реализует подход IoC/DI

### Основные понятия

* `Bean\Бин` - центральное понятие Spring. Бин - это объект какого-либо класса, который "управляется" Spring-ом (Spring management)
* Когда обычный объект называют "бином"? Когда этот объект был создан с использованием Spring и он может быть вызван через так называемый Spring-context приложения.
* Обычно бины помещаются в отдельный класс AppConfig, который, как правило, помечается аннотацией `@Configuration`.
* Каждый бин имеет две характеристики: "названием/id" и класс, на основе которого он создан.
* В случае, если мы создаем бин с помощью метода, например:

```
    @Bean
    public PasswordValidator passwordValidatorNotEmpty() {
        return new PasswordNotEmptyValidatorImpl();
    }
```

* То здесь id-бина - это название метода - `passwordValidatorNotEmpty`
* А класс/тип бина -  `PasswordValidator`

* Все создаваемые Spring бины помещаются в `Spring Context`, специальный контейнер, которым управляет Spring. 

Далее в Main необходимо объявить/создать applicationContext:

```java
AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
```

* Из Spring Context мы можем получить бин (извлечь) по id(уникальному имени) и типу(имени класса):

```java
PasswordValidator passwordValidator = applicationContext.getBean("passwordValidatorRegex", PasswordValidator.class);
```

## Обобщение

1. В Main мы создавали экземпляры каждого класса и связывали их между собой.
2. В Main2 мы обратились к контейнеру Spring (Spring Context) и попросили у него бин с типом `UsersController`
3. Данный бин к нам пришел с зависимостью на `UsersService`,а тот, в свою очередь зависит от всех других нужных нам и полезных бинов.
4. Чтобы бины были в контейнере (попали в контекст), создаем класс `AppConfig`, в котором перечисляем все необходимые бины.
5. Подход, когда логика создания компонентов приложения и их связывания выносится в отдельный модуль - называется Inversion of Control (IoC).

* Бин - это просто объект, компонент приложения, экземпляр какого-либо класса, НО он находится внутри контейнера/контекста Spring.

* `@Bean` - аннотация, которой мы помечаем метод, результатом работы которого является создание объекта нужного нам типа (объекта класса).

```
@Bean
public PasswordValidator passwordValidatorNotEmpty() {
    return new PasswordNotEmptyValidatorImpl();
}
```

* `passwordValidatorNotEmpty` - это название/id вашего бина типа `PasswordValidator`
* внутри метода описываем логику создания нашего бина, в конце обязательно `return`
* id-бина может быть абсолютно любым, главное - уникальным:

```
@Bean
public PasswordValidator xyz() {
    return new PasswordNotEmptyValidatorImpl();
}
```

* В метод, который помечен аннотацией `@Bean` можно подставить другие бины в параметрах метода.
* Если имеется несколько бинов, одинакового типа, то етсь созданных на основе одного класса, то уникальное название бина позволяет понять, какой бин нам нужен в каждом конкретном случае.
* Если бин по такому типу только один - на название бина может быть произвольным.

## Создание и получение бина

* Положить бин в контейнер можно с помощью аннотации `@Bean`
* Получить бин из контейнера можно с помощью:
  * `applicationContext.getBean(ТипНужногоБина.class)`
  * `applicationContext.getBean(Id-нужного-бина, ТипНужногоБина.class)`