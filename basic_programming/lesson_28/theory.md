# Накопленные знания

## Объектно-ориентированное программирование

### ООП - классы, объекты, методы, конструкторы, геттеры и сеттеры

* Поля классов - что это? как они выглядят?
- поля отражают состояние объектов (экземпляров) класса
- содержат (отражают) свойства объектов, модификаторы доступа к полям
- выглядят как перменные, у которых определены:
  - тип данных (8 примитивных, String)
  - имя поля, переменной
  - определенное значение
Пример:
  класс Car, поля объекта класса - цвет, вес, тип

* Конструкторы, геттеры и сеттеры - для чего они нужны?
  - как отличить конструктор в коде класса - называется как класс, ничего не возвращает
  - нужен для создания объектов класса
  - вызывается словом new 
  - конструкторов может быть много, их можно переопределят
  - конструктор может быть, в том числе, "пустым"
  - геттеры - позволяют получать данные (значения) из полей классов
  - сеттер - позволяют устанавливать значения полей классов

* Инкапсуляция - что это?
  - объединение в классе полей и методов, клас - это "капсула", которая их содержит
  - благодаря инкапсуляции можно обеспечить "сокрытие" данных 

* Полиморфизм - что это?
  - возможность переопределять методы, в том числе конструкторы
  - возможность метода обрабатывать данные разных типов
  - возможность называть методы ОДИНАКОВО

* Наследование:
- extends - позволяет наследовать свойства объектов из родительского класса, пишем в классе - ребенке
  знает ли класс-родитель о своих детях? - НЕТ
  знает ли класс-ребенок о своЕМ родителе? - ДА, родитель может быть только ОДИН

- super - это обращение к родительскому классу, получаем поля и методы
  
  - casting (down, upper) - это приведение типа объекта к типу одного из родственных классов
    (double) x - это uppercasting из int в double
    класс Shape - родитель. Circle, Rectangle, Triangle - это его "дети".  
  Можно проводить операции casting:
    Circle circle = (Circle) new Shape();
    (Circle) shape - это downcasting shape до класса - ребенка.
  Casting можно проводить в рамках одной "семьи".

  - класс Object - прародитель всех объектов во всех классах, все классы по умолчанию extend Object 
  
  - instanceof (boolean) - позволяет отфильтровать, понять, является ли объект объектом данного класса

Это примеры объектных переменных:
`Book book = new Book
Computer comp = new Computer`

## Абстрактные классы

Абстрактный класс — это «заготовка» для группы будущих классов, которые будут его от него наследоваться.
Нельзя создавать объекты в абстрактном классе.

Польза - основные поля этой группы классов указываются один раз в самом абстрактном классе, 
дочерние классы расширяют состав полей своими, дополнительными полями.
Методы - переопределяются в дочерних классах.

Примеры:
Абстрактный класс Pet (домашние животные) 
Дочерние классы - Cat, Dog, Pig, Cow 

Полезная статья:
https://javarush.com/groups/posts/1973-abstraktnihe-klassih-v-java-na-konkretnihkh-primerakh


## Interfaces and TDD
1. В Java можно создать структуру, у которой только абстрактные методы. 
Такие структуры называются **интерфейсами**, и определяются при помощи ключевого слова interface. 
Классы могут имплеменировать интерфейсы при помощи ключевого слова implements. 

В Java классы могут расширять (extends) только один класс, но могут имплементировать 
(implements) несколько интерфейсов. В этом случае имплементируемые интерфейсы перечисляются через запятую.

2. Подход **TDD (разработка через тестирование)**, очень популярен, и обладает рядом преимуществ. 

Его общая логика такова:

**Шаг 1** - реализуем класс (поля, конструкторы, геттеры, сеттеры и пр. методы класса).
Например, класс Employee.

**Шаг 2** - создаем интерфейс для работы (действий) с объектами класса, в котором перечисляем 
**только сигнатуры** необходимых нам методов.

Например, интерфейс Company, в котором заданы методы, но они не реализованы. 
Этими методами мы будем оперировать с объектами класса Employee.
Нам нужны методы:
- add
- remove
- find
- quantity (size)
- ...

**Шаг 3** - создаем класс CompanyImpl, который имплементирует интерфейс Company. 
В этом классе требуется реализовать все методы, которые указаны в интерфейсе.

**Шаг 4** - создаем класс CompanyImplTest.
В этом классе мы пишем методы-тесты для тех методов, которые 
требуют реализации.

**Шаг 5** - реализация методов.
На этом шаге пишется реализация методов, правильность работы которых, проверяется тестами.
